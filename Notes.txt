#Multitasking

->Executing several tasks simultaneously is  a concept of multitasking .
->There are two types of multitasking 
    * Process-based multitasking
    * Thread-based multitasking

-> Process-Based Multitasking- Executing several tasks simultaenously where each tasks is a seperate 
independent program (process) is called process based multitasking
Example: while typing java program in the editor , we can listen audio song from the same system yet 
same time we can download a file from net . All these tasks will be executed simultaneously and 
independent of each other. Hence it is process based multitasking.

Process Based Multitasking is best suitable at OS Level.

->Thread-Based Multitasking- Executing several parts simultaeously where each tasks is seperate 
independent part of a same program is called Thread-based multitasking and each independent part is called a Thread

Thread-Based multitasking is best suitable at programatic level

** whether it is process-based or thread-based, the main objective of multitasking is to reduce response time of the system and to improve performance 

->The main  important area of multithreading are:

*To develop multimedia graphics
*To develop the animations 
*To develop video games
*To develop web servers and application servers etc...

@# when compared with old languages, developing multithreaded applications in java  is very easy because
java provides inbuilt support for multithreading with rich API [Thread,Runnable,ThreadGroup....]

-----------------------Defining a thread----------------------------

->We can define a thread in the following two ways:
    >By extending Thread Class
    >By implementing Runnable interface

 
->Thread Scheduler
 It is a part of JVM. It is responsible to schedule threads that is if multiple threads are waiting to 
get a chance of execution then in which order threads will be executed is decided by Thread Scheduler.
We can't accept exact algorithm(round robin, first in first out..etc) followed by Thread Scheduler it is varied from JVM to JVM, and hence 
we can't accept thread execution order and exact output

Hence whenever situation comes to multithreading there is no guarantee for exact output,but we can 
provide several possible outputs.

------Importance of Thread class start() method----------

Thread Class start() method is responsible to *register the Thread with Thread scheduler and *all other
mandatory activities and *invoke run method hence, without executing Thread class start() method there is 
no chance of starting a new thread in java due to this Thread Class start() method is consider as
heart of multithreading.


**if we are not overriding run() method then Thread class run() method will be executed which has empty
implementation and hence we won't get any output
It is highly recommended to override run method otherwise don't go for multithreading concept

-> Which approch is best to define a Thread?
        Among two ways of defining a Thread implements Runnable approach is recommended.
    In the first approach our class always extends Thread class,there is no chance of extending any other
     class Hence we are missing inheritance benefit
    But in the second aproch while implementing Runnable interface we can extend any other class 
      Hence we won't miss any inheritance benefit because of above reason implementing runnable interface 
      is recommended then extending Thread class

------Thread's Priority-------------
->Every Thread has a priority in java even it is a default priority provided by JVM and custom priority
 provided by programmer
Thread class defines some following constants to represent some standard priorities:-
 #Thread.MIN_PRIORITY- 1
 #Thread.NORM_PRIORITY- 5
 #Thread.MAX_PRIORITY- 10

->Thread Scheduler will use priorities while allocating processor. The Thread which is having highest 
priority will get a chance first. 
**If two Threads having same priority then we cann't accept a exact execution order it depends on Thread
Scheduler

**The default priority only for the main thread is 5. But for all remaining threads default priority will be inherited 
from parent to child i.e whatever priority parent thread has the same priority will be there for the child thread.

->We can prevent a Thread execution by using the following methods:
   *yield()->This method causes to pause current executing thread to give a chance of waiting threads of same priority.If
        there is no waiting thread or all waiting threads have low priority then same thread can continue its execution
        If multiple threads are waiting with same priority then which waiting thread will get the chance we can't accpect it depends on thread scheduler.
   
   *join()->If a thread want to wait until completing some other thread then we should go for join() method.
        for example, if a thread t1 wants to wait until completing t2 then t1 has to call t2.join(). If t1 executes 
        t2.join() then immediately t1 will be entered into waiting state until t2 completes.Once t2 completes then t1 can continue its execution. 
        Every join method throws InterruptedException which is checked Exception and hence compulsory we should
        handle this exception otherwise we will get compile time error 

   *sleep()-> If a thread don't want to perform any operations for a particular amount of time then we should go for
        sleep method 
        Every sleep method throws InterruptedException which is checked Exception and hence compulsory we should
        handle this exception otherwise we will get compile time error 

----------how a thread can interrupt another thread?
    A thread can interrupt a sleeping thread or waiting thread by using interrupt() method of Thread class.
    
-------------------Synchronization in MultiThreading-------------

    Synchronized is a modifier applicable only for methods and blocks but not for classes and variables.
If multiple threads are trying to operate simultaneously on the same java object then there may be a chance of 
data inconsistency problem

To overcome this problem we should go for synchronized keyword if a method or block declared as a synchronized then
at a time only one thread is allowed to execute that method or block on the given object so that data inconsistency
problem will be resolved

**the main advantage of synchronized keyword is we can resolve data inconsistency problems but the main 
disadvantage of synchronized keyword is it increases waiting time of threads and creates performance problems and hence,
if there is no specific requirements then it is not recommended to use synchronized keyword.

->Internally, syncronization concept is implemented by using lock, every object in java has a unique lock whenever 
we are using synchronized keyword then only lock concept will come into the picture. 
If a thread wants to execute synchronized method on the given object first, it has to get lock of that object .Once
thread got the lock then it is allowed to execute any synchronized method on that object.Once method execution 
completes automatically thread releases the lock. Acquiring and releasing lock internally takes care by JVM and programmer is not responsible for this activity

**while a thread executing synchronized method on the given object the remaining threads are not allowed to execute any syncronization method 
on the same object but remaining threads are allowed to execute non-synchronized methods simultaneously.
Lock concept is implemented based on object but not based on method 

->synchronized area - wherever we are performing update operation[Add/delete/update/replace] i.e, where state of object changing
non-synchronized area- wherever object state won't be changed like read() operation

For Example: class ReservationSystem{

    checkAvailabilty{ //non-synchronized
        read() operation
    }
    synchronized bookticket(){ //synchronized method
        update() operation
    }
}

----------------------------------Synchronized block---------------------------
If very few lines of the code requires syncronization then it is not recommended to declare entire method as 
synchronized, we have to enclose those few lines of the code by using synchronized block.

The main advantage of synchronized block over synchronized method is it reduces waiting time of threads and improves
performance of the application.

We can declare syncronized block as follows:
1) to get a lock of current object   |    2) to get a lock of a particular object b  |    3)To get a class level lock               |
    syncronized(this){               |        syncronized(b){                        |         syncronized(Display.class){          |
        -------                      |            -----                              |           ----                               |
    }                                |          }                                    |           }                                  |
                                     |                                               |                                              |
If a thread got lock of current      |  if a thread got lock of particular object 'b'| if a thraed got class level lock of 'Display'| 
object then only it is allowed to    |  then only it is allowed to execute this area | class then, only it is allowed to execute    |
execute this area                    |                                               |  this area                                   |

**Lock concept applicable for object types and class types but not for primitive type hence, we can't pass 
primitive type as a agruments otherwise we will get compile time error saying unexpected type found in reference

For example;
            int x=10;
                synchronized(x){----}         shows above error of unexpected reference


----*Interview based Questions-----
Q1] What is synchronized keyword and where we can apply?
Q2] Explain advantage of synchronized keyword?
Q3] Explain disadvantage of synchronized keyword?
Q4] What is Race condition?
    Ans- if multiple thraeds are operating on same java object then there may be a chance of data inconsistency 
        problem this is called race condition. we can overcome this problem by using synchronized keyword.

Q5] What is Object Lock and when it is required? whenever thread wants to execute instance synchronized method it is required object level lock. 
Q6] What is class level lock and when it is required? whenever thread wants to execute static synchronized method it is required class level lock.
Q7] What is the difference b/w  class level lock and object level lock?
Q8] what is synchronized block?
Q9] how to declare synchronized block to get a lock of current object?
Q10] how to declare synchronized block to get a class level lock?
Q11] What is a advantage of synchronized block over synchronized method? performance increases by reducing waiting time of the threads
Q12] Is a thread can require multiple locks simultaneously? Yes, from different objects.
For Example;
Class X{
    public synchronized void m1(){
        //here, thread has lock of X object
        Y y=new Y();

        synchronized(y){
            //here thread has locks of X and Y
            Z z=new Z();
            synchronized(z){
                ------ //here thread has locks of X,Y,Z 
            }
            ---
        }
    }
}
Q13] What is synchronized statement?(Interview people created terminology: The statements present in synchronized
method and synchronized block are called synchronized statements.)

-------------------Inter-Thread Communication-------------------------------

Two threads can communicate with each other by using wait(), notify(), and notifyAll() methods. The thread which is 
expecting updation  is responsible to call wait() method then immediately the thread will enter into waiting  state.

The thread which is responsible to perform updation after performing updation it is responsible to call 
notify() method then waiting thread will get that modification and continue its execution with those updated items.

**wait(), notify(), and notifyAll() methods present in Object class not in Thread class because thread can call 
these methods on any java objects.

To call wait(), notify(), and notifyAll() methods on any objects, thread should be a owner of that objects i.e, 
thread should have lock of that object that is thread should be inside synchronized area.

hence we can call wait(), notify(), and notifyAll() methods only from synchronized area otherwise we will get 
RuntimeException :IllegalMonitorStateException.

`If a thread calls wait() method on any object it immediately it releases the lock of that particular object and 
enter into waiting state`

If a thread calls notify() method on any object, it releases the lock of that object but may not immmediately
except wait(), notify() and notifyAll() there is no other method where thread releases the lock.

Every wait() throws InterruptedException which is checked exception hence, whever we are using wait() then 
compulsotry we should handle these exception otherwise we will get compile time error. 

->Example; ++ Producer-Consumer problem
producer thread is reponsible to produce items to the queue and Consumer thread is responsible to consume items 
from the queue. If queue is empty the consumer thread will call wait() and entered into waiting state after 
producing items to the queue, producer thread is responsible to call notify() then waiting consumer will get the 
notification and continue its execution with updated items

Producer thread                                      |         Consumer Thread
class ProducerThread{                                |     class ConsumerThread{
    produce(){                                       |             consume(){
        synchronized(q){                             |                 synchronized(q){
            //produce items to the queue             |                     if(q.isEmpty())
                q.notify();                          |                          q.wait();
            }                                        |                     else
    }                                                |                        //consume items
}                                                    |                     }
                                                     |                 } }

We can use notify() method to give a notification for only one waiting thread if multiple thread are waiting then
only one thread will be notified and the remaining threads have to wait for further notifications which thread 
will be notified we can't expect it depends on JVM
We can use notifyAll() to give the notification for all waiting threads of a particular objects. Eventhough 
multiple threads are notifies but execution will be performed one by one because threads require lock and only 
one lock is available.
on which object we are calling wait() method thread requires lock of that particular object

->DeadLock- If two threads are waiting for each other forever such type of infinite waiting is called DeadLock.

synchronized keyword is the only reason for deadlock situation hence, while using synchronized keyword we have to
take special care. 
There is no resolution technique for deadlock but several prevention technique are available.

----------------------Deadlock Vs Starvation---------------------
Long waiting of a thread where waiting never ends is called deadlock whereas long waiting of a thread where 
waiting ends at certain point is called starvation. For example, low priority threads has to wait until 
completing all high priority threads it may be long waiting but ends at certain point, which is nothing but 
starvation.

----------------------Daemon Threads--------------------
The threads which are executing in the background are called Daemon threads
    Example;Garabage Collector, Signal Dispatcher , Attach Listener

The main objective of Daemon threads is to provide support for non-Daemon threads(main thread). For example; if 
main thread runs with low memory then JVM runs garbage collector to destroy useless objects so that no. of bits 
of few memory improved with this free memory main thread can continue its execution.
Usually, daemon threads having low priority but based on our requirement but daemon threads can run with high 
priority also
We can check daemon nature of a thread by using isDaemon() method of Thread class-public boolean isDaemon();
We can change daemon nature of a thread by using setDaemon() method -public void setDaemon(boolean b); ,but 
changing daemon nature is possible before starting of a thread only, after starting a thread if we are trying to 
change daemon nature we will get runtimeException: IllegalThreadStateException.
By default main thread is always non-Daemon and for all remaining threads daemon nature will be inherited from 
parent to child i.e if parent thread is daemon then automatically child thread is also daemon and if parent 
thread is not daemon then child thread is also not daemon.
** it is impossible to change daemon nature of main thread because it is already started by JVM at begining.

@whenever last non-daemon thread terminates automatically all daemon threads will be terminated irrespective of 
their position. 

//Java Multithreading concept is implemented by using the following two models:
1) Green Thread model-> The thread which is managed completely by JVM without taking underlined OS support is 
called green thread. Very few operating systems like some Solaris provide support for green thread model anyway 
green thread model is deprecated and not recommended to use.

2) Native OS Model-> the thread which is managed by JVM with the help of underlined OS, is called Native OS model.
All windows based operating system provide support for native OS model.

Q} How to stop a thread?? we can stop a thread execution by using stop() method of a Thread class. If we call 
stop() method then immediately the thread will enter into dead state. Eventhough stop() method is deprecated and 
not recommended to use.