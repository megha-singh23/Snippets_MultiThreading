#Multitasking

->Executing several tasks simultaneously is  a concept of multitasking .
->There are two types of multitasking 
    * Process-based multitasking
    * Thread-based multitasking

-> Process-Based Multitasking- Executing several tasks simultaenously where each tasks is a seperate 
independent program (process) is called process based multitasking
Example: while typing java program in the editor , we can listen audio song from the same system yet 
same time we can download a file from net . All these tasks will be executed simultaneously and 
independent of each other. Hence it is process based multitasking.

Process Based Multitasking is best suitable at OS Level.

->Thread-Based Multitasking- Executing several parts simultaeously where each tasks is seperate 
independent part of a same program is called Thread-based multitasking and each independent part is called a Thread

Thread-Based multitasking is best suitable at programatic level

** whether it is process-based or thread-based, the main objective of multitasking is to reduce response time of the system and to improve performance 

->The main  important area of multithreading are:

*To develop multimedia graphics
*To develop the animations 
*To develop video games
*To develop web servers and application servers etc...

@# when compared with old languages, developing multithreaded applications in java  is very easy because
java provides inbuilt support for multithreading with rich API [Thread,Runnable,ThreadGroup....]

-----------------------Defining a thread----------------------------

->We can define a thread in the following two ways:
    >By extending Thread Class
    >By implementing Runnable interface

 
->Thread Scheduler
 It is a part of JVM. It is responsible to schedule threads that is if multiple threads are waiting to 
get a chance of execution then in which order threads will be executed is decided by Thread Scheduler.
We can't accept exact algorithm(round robin, first in first out..etc) followed by Thread Scheduler it is varied from JVM to JVM, and hence 
we can't accept thread execution order and exact output

Hence whenever situation comes to multithreading there is no guarantee for exact output,but we can 
provide several possible outputs.

------Importance of Thread class start() method----------

Thread Class start() method is responsible to *register the Thread with Thread scheduler and *all other
mandatory activities and *invoke run method hence, without executing Thread class start() method there is 
no chance of starting a new thread in java due to this Thread Class start() method is consider as
heart of multithreading.


**if we are not overriding run() method then Thread class run() method will be executed which has empty
implementation and hence we won't get any output
It is highly recommended to override run method otherwise don't go for multithreading concept

-> Which approch is best to define a Thread?
        Among two ways of defining a Thread implements Runnable approach is recommended.
    In the first approach our class always extends Thread class,there is no chance of extending any other
     class Hence we are missing inheritance benefit
    But in the second aproch while implementing Runnable interface we can extend any other class 
      Hence we won't miss any inheritance benefit because of above reason implementing runnable interface 
      is recommended then extending Thread class

------Thread's Priority-------------
->Every Thread has a priority in java even it is a default priority provided by JVM and custom priority
 provided by programmer
Thread class defines some following constants to represent some standard priorities:-
 #Thread.MIN_PRIORITY- 1
 #Thread.NORM_PRIORITY- 5
 #Thread.MAX_PRIORITY- 10

->Thread Scheduler will use priorities while allocating processor. The Thread which is having highest 
priority will get a chance first. 
**If two Threads having same priority then we cann't accept a exact execution order it depends on Thread
Scheduler

**The default priority only for the main thread is 5. But for all remaining threads default priority will be inherited 
from parent to child i.e whatever priority parent thread has the same priority will be there for the child thread.

->We can prevent a Thread execution by using the following methods:
   *yield()->This method causes to pause current executing thread to give a chance of waiting threads of same priority.If
        there is no waiting thread or all waiting threads have low priority then same thread can continue its execution
        If multiple threads are waiting with same priority then which waiting thread will get the chance we can't accpect it depends on thread scheduler.
   
   *join()->If a thread want to wait until completing some other thread then we should go for join() method.
        for example, if a thread t1 wants to wait until completing t2 then t1 has to call t2.join(). If t1 executes 
        t2.join() then immediately t1 will be entered into waiting state until t2 completes.Once t2 completes then t1 can continue its execution. 
        Every join method throws InterruptedException which is checked Exception and hence compulsory we should
        handle this exception otherwise we will get compile time error 

   *sleep()-> If a thread don't want to perform any operations for a particular amount of time then we should go for
        sleep method 
        Every sleep method throws InterruptedException which is checked Exception and hence compulsory we should
        handle this exception otherwise we will get compile time error 

----------how a thread can interrupt another thread?
    A thread can interrupt a sleeping thread or waiting thread by using interrupt() method of Thread class.
    
-------------------Syncronization in MultiThreading-------------

    syncronized is a modifier applicable only for methods and blocks but not for classes and variables.
If multiple threads are trying to operate simultaneously on the same java object then there may be a chance of 
data inconsistency problem

To overcome this problem we should go for syncronized keyword if a method or block declared as a syncronized then
at a time only one thread is allowed to execute that method or block on the given object so that data inconsistency
problem will be resolved

**the main advantage of syncronized keyword is we can resolve data inconsistency problems but the main 
disadvantage of syncronized keyword is it increases waiting time of threads and creates performance problems and hence,
if there is no specific requirements then it is not recommended to use syncronized keyword.

->Internally, syncronization concept is implemented by using lock, every object in java has a unique lock whenever 
we are using syncronized keyword then only lock concept will come into the picture. 
If a thread wants to execute syncronized method on the given object first, it has to get lock of that object .Once
thread got the lock then it is allowed to execute any syncronized method on that object.Once method execution 
completes automatically thread releases the lock. Acquiring and releasing lock internally takes care by JVM and programmer is not responsible for this activity

**while a thread executing syncronized method on the given object the remaining threads are not allowed to execute any syncronization method 
on the same object but remaining threads are allowed to execute non-syncronized methods simultaneously.
Lock concept is implemented based on object but not based on method 

->syncronized area - wherever we are performing update operation[Add/delete/update/replace] i.e, where state of object changing
non-syncronized area- wherever object state won't be changed like read() operation

For Example: class ReservationSystem{

    checkAvailabilty{ //non-syncronized
        read() operation
    }
    syncronized bookticket(){ //syncronized method
        update() operation
    }
}

